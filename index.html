<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Low Poly Cabin in the Woods</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas { 
            display: block; 
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            pointer-events: none;
        }
        /* Add crosshair style */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h3>Controls:</h3>
        <p>W, A, S, D - Move</p>
        <p>Mouse - Look around</p>
        <p>Space - Jump</p>
        <p>Shift - Run</p>
        <p>Left Click - Shoot</p>
    </div>
    
    <!-- Add crosshair -->
    <div id="crosshair">
        <svg width="20" height="20" xmlns="http://www.w3.org/2000/svg">
            <circle cx="10" cy="10" r="8" stroke="white" stroke-width="2" fill="none" opacity="0.8"/>
            <circle cx="10" cy="10" r="1" fill="white" opacity="0.8"/>
        </svg>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main variables
        let scene, camera, renderer;
        let cabin, ground;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let canJump = true;
        let isRunning = false;
        let gun;
        let isShooting = false;
        let bullets = [];
        let zombies = [];
        let playerHealth = 100;
        let healthBarElement;
        let zombieSpawnInterval; // Interval for spawning zombies
        
        // Player physics
        let playerVelocity = new THREE.Vector3();
        let playerDirection = new THREE.Vector3();
        const playerHeight = 1.8;
        let playerIsOnGround = true;
        
        // Clock for consistent movement speed
        const clock = new THREE.Clock();
        
        // Colors
        const COLORS = {
            SKY: 0x87CEEB,
            GROUND: 0xE69138,
            CABIN_BODY: 0x8B4513,
            CABIN_ROOF: 0x3D2817,
            TREES: 0xE67E22,
            TREE_TRUNK: 0x5D4037
        };
        
        init();
        animate();
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.SKY);
            
            // Add fog for atmosphere
            scene.fog = new THREE.Fog(COLORS.SKY, 20, 60);
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, playerHeight, 8);
            camera.lookAt(0, playerHeight, 0);
            
            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            addLights();
            
            // Create environment
            createGround();
            createCabin();
            createTrees();
            createClouds();
            createGun();
            createZombies(5); // Start with fewer zombies
            createHealthBar();
            
            // Start zombie spawning
            zombieSpawnInterval = setInterval(spawnZombie, 5000); // Spawn a zombie every 5 seconds
            
            // Set up controls
            setupControls();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function addLights() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(10, 20, 15);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            scene.add(sunLight);
            
            // Fill light
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);
        }
        
        function createGround() {
            // Create ground plane
            const groundGeometry = new THREE.PlaneGeometry(80, 80);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: COLORS.GROUND });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add grass instances
            createGrass();
        }
        
        function createGrass() {
            // Create simple grass blades
            const grassGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.1, 3);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: COLORS.GROUND });
            
            // Add many grass blades
            const grassCount = 1000;
            for (let i = 0; i < grassCount; i++) {
                const grassBlade = new THREE.Mesh(grassGeometry, grassMaterial);
                
                // Random position but not too close to cabin
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 40;
                    z = (Math.random() - 0.5) * 40;
                } while (Math.sqrt(x * x + z * z) < 3); // Keep away from cabin
                
                grassBlade.position.set(x, 0.05, z);
                grassBlade.rotation.x = Math.random() * 0.2;
                grassBlade.rotation.z = Math.random() * Math.PI;
                scene.add(grassBlade);
            }
        }
        
        function createCabin() {
            // Create cabin group
            cabin = new THREE.Group();
            
            // Cabin body
            const bodyGeometry = new THREE.BoxGeometry(3, 2, 2.5);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: COLORS.CABIN_BODY });
            const cabinBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            cabinBody.position.y = 1;
            cabinBody.castShadow = true;
            cabinBody.receiveShadow = true;
            cabin.add(cabinBody);
            
            // Cabin roof
            const roofGeometry = new THREE.ConeGeometry(2.2, 1.5, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: COLORS.CABIN_ROOF });
            const cabinRoof = new THREE.Mesh(roofGeometry, roofMaterial);
            cabinRoof.position.y = 2.75;
            cabinRoof.rotation.y = Math.PI / 4;
            cabinRoof.castShadow = true;
            cabinRoof.receiveShadow = true;
            cabin.add(cabinRoof);
            
            // Door
            const doorGeometry = new THREE.PlaneGeometry(0.8, 1.2);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x4E342E });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.6, 1.26);
            cabin.add(door);
            
            // Windows
            const windowGeometry = new THREE.PlaneGeometry(0.5, 0.5);
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0xB3E5FC });
            
            // Front window
            const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow.position.set(0.8, 1.2, 1.26);
            cabin.add(frontWindow);
            
            // Side window
            const sideWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            sideWindow.position.set(1.51, 1.2, 0);
            sideWindow.rotation.y = Math.PI / 2;
            cabin.add(sideWindow);
            
            // Chimney
            const chimneyGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);
            const chimneyMaterial = new THREE.MeshLambertMaterial({ color: 0x795548 });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(0.8, 3, 0.5);
            chimney.castShadow = true;
            cabin.add(chimney);
            
            // Smoke particles
            const smokeGeometry = new THREE.SphereGeometry(0.1, 4, 4);
            const smokeMaterial = new THREE.MeshBasicMaterial({ color: 0xDDDDDD, transparent: true, opacity: 0.7 });
            
            for (let i = 0; i < 5; i++) {
                const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);
                smoke.position.set(
                    0.8 + (Math.random() - 0.5) * 0.1,
                    3.5 + i * 0.2,
                    0.5 + (Math.random() - 0.5) * 0.1
                );
                smoke.scale.set(
                    1 + i * 0.2,
                    1 + i * 0.2,
                    1 + i * 0.2
                );
                cabin.add(smoke);
                
                // Animate smoke
                animateSmoke(smoke);
            }
            
            scene.add(cabin);
        }
        
        function animateSmoke(smoke) {
            const startY = smoke.position.y;
            const startOpacity = smoke.material.opacity;
            
            // Random animation speed
            const speed = 0.2 + Math.random() * 0.3;
            
            function update() {
                smoke.position.y += 0.003 * speed;
                smoke.material.opacity -= 0.001 * speed;
                
                // Reset when opacity gets too low
                if (smoke.material.opacity <= 0) {
                    smoke.position.y = startY;
                    smoke.material.opacity = startOpacity;
                    smoke.position.x = 0.8 + (Math.random() - 0.5) * 0.1;
                    smoke.position.z = 0.5 + (Math.random() - 0.5) * 0.1;
                }
                
                requestAnimationFrame(update);
            }
            
            update();
        }
        
        function createTrees() {
            // Create trees around the cabin
            const treeCount = 20;
            
            for (let i = 0; i < treeCount; i++) {
                // Calculate position in a circle around cabin
                const angle = (i / treeCount) * Math.PI * 2;
                const radius = 6 + Math.random() * 15;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                createTree(x, z);
            }
            
            // Add some random trees further away
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 20;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                createTree(x, z);
            }
        }
        
        function createTree(x, z) {
            // Create a tree group
            const tree = new THREE.Group();
            tree.position.set(x, 0, z);
            
            // Random scaling
            const scale = 0.8 + Math.random() * 0.7;
            tree.scale.set(scale, scale, scale);
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1, 5);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: COLORS.TREE_TRUNK });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.5;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Tree foliage (stacked triangles)
            const foliageMaterial = new THREE.MeshLambertMaterial({ color: COLORS.TREES });
            
            // Create several layers of foliage
            const layers = 3 + Math.floor(Math.random() * 2);
            for (let i = 0; i < layers; i++) {
                const coneHeight = 1.2;
                const coneRadius = 0.7 - (i * 0.1);
                const foliageGeometry = new THREE.ConeGeometry(coneRadius, coneHeight, 4);
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                
                foliage.position.y = 1 + (i * 0.7);
                foliage.castShadow = true;
                tree.add(foliage);
            }
            
            scene.add(tree);
        }
        
        function createClouds() {
            const cloudGeometry = new THREE.SphereGeometry(1, 7, 7);
            const cloudMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            
            // Create several clouds
            for (let i = 0; i < 8; i++) {
                const cloud = new THREE.Group();
                
                // Random position
                const x = (Math.random() - 0.5) * 60;
                const z = (Math.random() - 0.5) * 60;
                const y = 20 + Math.random() * 5;
                
                cloud.position.set(x, y, z);
                
                // Add several spheres to create cloud shape
                const parts = 3 + Math.floor(Math.random() * 3);
                for (let j = 0; j < parts; j++) {
                    const partX = (Math.random() - 0.5) * 2;
                    const partY = (Math.random() - 0.5) * 0.5;
                    const partZ = (Math.random() - 0.5) * 2;
                    
                    const scale = 0.8 + Math.random() * 0.5;
                    
                    const cloudPart = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloudPart.position.set(partX, partY, partZ);
                    cloudPart.scale.set(scale, 0.4, scale);
                    cloud.add(cloudPart);
                }
                
                scene.add(cloud);
                
                // Animate cloud
                animateCloud(cloud);
            }
        }
        
        function animateCloud(cloud) {
            // Random movement speed
            const speed = 0.01 + Math.random() * 0.01;
            const direction = Math.random() > 0.5 ? 1 : -1;
            
            function update() {
                cloud.position.x += speed * direction;
                
                // Reset when out of bounds
                if (Math.abs(cloud.position.x) > 40) {
                    cloud.position.x = -40 * direction;
                    cloud.position.z = (Math.random() - 0.5) * 60;
                }
                
                requestAnimationFrame(update);
            }
            
            update();
        }
        
        function createGun() {
            gun = new THREE.Group();
            
            // Gun body
            const gunBody = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.1, 0.3),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            
            // Gun handle
            const gunHandle = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.15, 0.08),
                new THREE.MeshLambertMaterial({ color: 0x222222 })
            );
            gunHandle.position.set(0, -0.12, -0.05);
            
            gun.add(gunBody);
            gun.add(gunHandle);
            
            // Position the gun in front of the camera
            gun.position.set(0.2, -0.15, -0.3);
            camera.add(gun);
        }
        
        function createZombies(count) {
            for (let i = 0; i < count; i++) {
                // Random position around the cabin
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 20;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                createZombie(x, 0, z);
            }
        }
        
        function createZombie(x, y, z) {
            const zombie = new THREE.Group();
            
            // Zombie body
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.2, 1.5, 4);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x2E7D32 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            zombie.add(body);
            
            // Zombie head
            const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x2E7D32 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            zombie.add(head);
            
            // Zombie arms
            const armGeometry = new THREE.BoxGeometry(0.2, 0.7, 0.2);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0x2E7D32 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(0.5, 0.9, 0);
            leftArm.rotation.z = -Math.PI / 4;
            zombie.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(-0.5, 0.9, 0);
            rightArm.rotation.z = Math.PI / 4;
            zombie.add(rightArm);
            
            // Position zombie
            zombie.position.set(x, y, z);
            
            // Add zombie data
            zombie.userData = {
                health: 100,
                speed: 0.8 + Math.random() * 0.7,
                type: 'zombie'
            };
            
            // Create a separate container for the health bar that will always face the camera
            const healthBarContainer = new THREE.Object3D();
            healthBarContainer.position.y = 2.2;
            zombie.add(healthBarContainer);
            
            // Health bar background
            const healthBarWidth = 1;
            const healthBarHeight = 0.1;
            const healthBarBg = new THREE.Mesh(
                new THREE.PlaneGeometry(healthBarWidth, healthBarHeight),
                new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.7, transparent: true })
            );
            healthBarContainer.add(healthBarBg);
            
            // Health bar fill
            const healthBar = new THREE.Mesh(
                new THREE.PlaneGeometry(healthBarWidth, healthBarHeight),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            healthBar.position.z = 0.01; // Slightly in front of background
            healthBarContainer.add(healthBar);
            
            // Store reference to health bar and its container
            zombie.userData.healthBar = healthBar;
            zombie.userData.healthBarBg = healthBarBg;
            zombie.userData.healthBarContainer = healthBarContainer;
            
            scene.add(zombie);
            zombies.push(zombie);
        }
        
        function createHealthBar() {
            // Create player health bar
            healthBarElement = document.createElement('div');
            healthBarElement.style.position = 'absolute';
            healthBarElement.style.bottom = '20px';
            healthBarElement.style.left = '20px';
            healthBarElement.style.width = '200px';
            healthBarElement.style.height = '20px';
            healthBarElement.style.backgroundColor = '#333';
            healthBarElement.style.border = '2px solid #fff';
            healthBarElement.style.borderRadius = '5px';
            
            const healthFill = document.createElement('div');
            healthFill.id = 'health-fill';
            healthFill.style.width = '100%';
            healthFill.style.height = '100%';
            healthFill.style.backgroundColor = '#00ff00';
            healthFill.style.transition = 'width 0.3s';
            
            healthBarElement.appendChild(healthFill);
            document.body.appendChild(healthBarElement);
        }
        
        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = `${playerHealth}%`;
            
            // Change color based on health
            if (playerHealth > 60) {
                healthFill.style.backgroundColor = '#00ff00'; // Green
            } else if (playerHealth > 30) {
                healthFill.style.backgroundColor = '#ffff00'; // Yellow
            } else {
                healthFill.style.backgroundColor = '#ff0000'; // Red
            }
            
            // Game over if health reaches 0
            if (playerHealth <= 0) {
                alert('Game Over! Refresh to play again.');
                document.exitPointerLock();
            }
        }
        
        function updateZombies(delta) {
            for (let i = zombies.length - 1; i >= 0; i--) {
                const zombie = zombies[i];
                
                // Move zombie towards player
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, zombie.position).normalize();
                
                // Only move on X and Z axes
                direction.y = 0;
                
                // Move zombie
                zombie.position.add(direction.multiplyScalar(zombie.userData.speed * delta));
                
                // Make zombie face the player
                zombie.lookAt(camera.position.x, zombie.position.y, camera.position.z);
                
                // Check for collision with player
                if (zombie.position.distanceTo(camera.position) < 1.5) {
                    // Damage player
                    playerHealth -= 0.5;
                    updateHealthBar();
                }
                
                // Update zombie health bar scale and make it face camera
                if (zombie.userData.healthBarContainer) {
                    zombie.userData.healthBarContainer.lookAt(camera.position);
                }
            }
        }
        
        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Move bullet
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));
                
                // Check for collision with zombies
                for (let j = zombies.length - 1; j >= 0; j--) {
                    const zombie = zombies[j];
                    
                    if (bullet.position.distanceTo(zombie.position) < 1) {
                        // Damage zombie
                        zombie.userData.health -= 25;
                        
                        // Immediately update the health bar for THIS specific zombie
                        if (zombie.userData.healthBar) {
                            // Make sure we're updating the correct zombie's health bar
                            zombie.userData.healthBar.scale.x = zombie.userData.health / 100;
                            
                            // Adjust position to keep the bar aligned to the left as it shrinks
                            const offset = (1 - zombie.userData.health / 100) * -0.5;
                            zombie.userData.healthBar.position.x = offset;
                            
                            // Make sure the health bar is facing the camera
                            zombie.userData.healthBar.lookAt(camera.position);
                            zombie.userData.healthBarBg.lookAt(camera.position);
                        }
                        
                        // Remove bullet
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        
                        // Remove zombie if health <= 0
                        if (zombie.userData.health <= 0) {
                            scene.remove(zombie);
                            zombies.splice(j, 1);
                        }
                        
                        break;
                    }
                }
                
                // Remove bullets after 2 seconds or if they go too far
                if (bullet && Date.now() - bullet.userData.createdAt > 2000 || 
                    bullet && bullet.position.distanceTo(camera.position) > 50) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        moveForward = true;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        moveBackward = true;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        moveLeft = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        moveRight = true;
                        break;
                    case 'Space':
                        if (playerIsOnGround) {
                            playerVelocity.y = 8;
                            playerIsOnGround = false;
                        }
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        isRunning = true;
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch (event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        moveForward = false;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        moveBackward = false;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        moveLeft = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        moveRight = false;
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight':
                        isRunning = false;
                        break;
                }
            });
            
            // Mouse look controls
            // Variables to track camera rotation
            let rotationX = 0;
            let rotationY = 0;
            
            document.addEventListener('mousemove', (event) => {
                // Only enable after user clicks
                if (document.pointerLockElement !== document.body) return;
                
                // Adjust camera rotation based on mouse movement
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;
                
                // Update rotation values
                rotationY -= movementX * 0.002;
                rotationX -= movementY * 0.002;
                
                // Clamp vertical rotation to avoid flipping
                rotationX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, rotationX));
                
                // Apply rotations in the correct order
                camera.rotation.order = 'YXZ'; // Important for FPS controls
                camera.rotation.x = rotationX;
                camera.rotation.y = rotationY;
            });
            
            // Lock pointer on click
            renderer.domElement.addEventListener('click', () => {
                if (document.pointerLockElement !== document.body) {
                    document.body.requestPointerLock();
                }
            });
            
            // Add mouse click for shooting
            document.addEventListener('mousedown', (event) => {
                if (document.pointerLockElement === document.body && event.button === 0) {
                    shootBullet();
                }
            });
        }
        
        function shootBullet() {
            if (isShooting) return; // Prevent rapid fire
            
            isShooting = true;
            setTimeout(() => { isShooting = false; }, 500); // Cooldown between shots
            
            // Create bullet
            const bulletGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Position bullet at gun tip
            bullet.position.set(camera.position.x, camera.position.y, camera.position.z);
            
            // Set bullet direction based on camera direction
            bullet.userData.velocity = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).multiplyScalar(20);
            bullet.userData.alive = true;
            bullet.userData.createdAt = Date.now();
            
            scene.add(bullet);
            bullets.push(bullet);
            
            // Gun recoil animation
            gun.position.z += 0.05;
            setTimeout(() => {
                gun.position.z -= 0.05;
            }, 50);
        }
        
        function updatePlayer(delta) {
            // Apply gravity
            playerVelocity.y -= 15 * delta;
            
            // Check if player is on ground
            if (camera.position.y <= playerHeight) {
                playerVelocity.y = 0;
                camera.position.y = playerHeight;
                playerIsOnGround = true;
            } else {
                playerIsOnGround = false;
            }
            
            // Get movement speed
            const speedMultiplier = isRunning ? 2 : 1;
            const speed = 5 * speedMultiplier * delta;
            
            // Get movement direction from camera orientation
            const angle = camera.rotation.y;
            playerDirection.set(0, 0, 0);
            
            if (moveForward) {
                playerDirection.z = -Math.cos(angle) * speed;
                playerDirection.x = -Math.sin(angle) * speed;
            }
            if (moveBackward) {
                playerDirection.z = Math.cos(angle) * speed;
                playerDirection.x = Math.sin(angle) * speed;
            }
            if (moveLeft) {
                playerDirection.z = Math.sin(angle) * speed;
                playerDirection.x = -Math.cos(angle) * speed;
            }
            if (moveRight) {
                playerDirection.z = -Math.sin(angle) * speed;
                playerDirection.x = Math.cos(angle) * speed;
            }
            
            // Apply movement
            camera.position.x += playerDirection.x;
            camera.position.z += playerDirection.z;
            camera.position.y += playerVelocity.y * delta;
            
            // Boundary check - don't let player go off the ground
            const boundarySize = 39;
            if (camera.position.x > boundarySize) camera.position.x = boundarySize;
            if (camera.position.x < -boundarySize) camera.position.x = -boundarySize;
            if (camera.position.z > boundarySize) camera.position.z = boundarySize;
            if (camera.position.z < -boundarySize) camera.position.z = -boundarySize;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            updatePlayer(delta);
            updateBullets(delta);
            updateZombies(delta);
            
            // Make all zombie health bars face the camera
            zombies.forEach(zombie => {
                if (zombie.userData.healthBarContainer) {
                    zombie.userData.healthBarContainer.lookAt(camera.position);
                }
            });
            
            renderer.render(scene, camera);
        }
        
        function spawnZombie() {
            // Don't spawn too many zombies
            if (zombies.length >= 20) return;
            
            // Random position around the player, but not too close
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 10;
            const x = camera.position.x + Math.cos(angle) * radius;
            const z = camera.position.z + Math.sin(angle) * radius;
            
            createZombie(x, 0, z);
        }
    </script>
</body>
</html>